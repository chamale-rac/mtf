\section*{Problema 3}

\subsection*{\textit{\textbf{Inciso A}}}
Bueno, cada operación de transformación está asociada con un costo. Y el costo de una serie de operaciones de transformación está dada por la suma de los costos individuales. Básicamente, nuestro \textit{problema} puede ser definido como: Encontrar una secuencia de operaciones de transformación óptima (osea con el mínimo costo) para transformar \(X\) en \(Y\).\\

Para identificar una subestructura óptima, primero debemos encontrar las decisiones necesarias para producir subproblemas. En este caso, como definir los índices \(i\) e \(j\) sobre \(X\) y \(Y\) para formar subcadenas para los subproblemas.\\

Consideremos una secuencia de operaciones \((o_{1},\dots ,o_{k})\) dada como óptima. Habiéndose aplicado alguna de las operaciones, podemos decir que se debe haber aplicado una secuencia de operaciones óptima para transformar las subcadenas de \(X\) y \(Y\). \\

Dado que debemos evaluar caractér por caracter, quizá subcadena es un termino ambiguo, específicamente para la generación de subproblemas la estrategia debe ser sólida y requiere de comenzar evaluando ya sea los prefijos o sufijos de la cadena. Dado que debemos utilizar un acercamiente \textit{bottom-up} podemos elegir evaluar los prefijos más cortos. El caso base sucede cuando no se necesita ninguna transformación.\\

\subsection*{\textit{\textbf{Inciso B}}}

\begin{center}
\begin{tabular}{ c |c |c |c |c |c |c }
     & Y[0] & Y[1] & Y[2] & \(\dots\) & Y[m-1] & Y[m]\\ 
     \hline
    X[0] & & & & & & \\ 
    \hline
    X[1] & & & & & & \\ 
    \hline
    X[2] & & & & & & \\ 
    \hline
    \(\dots\) & & & & & & \\ 
    \hline
    X[n-1] & & & & & & \\ 
    \hline
    X[n] & & & & & & \\ 
\end{tabular}
\end{center}

\begin{center}
\small\textcolor{FSBlue}{Tabla que se llenaría durante la ejecución de la solución \textit{bottom-up}.}
\end{center}

Cada celda \(T[i][j]\) es la \textit{minima edit distance} para transformar el prefijo de \(X\) en el prefijo del mismo tamaño de \(Y\).\\

Una vez que todos los valores de las celdas se hayan sido calculados, el valor de la celda \(T[n][m]\) representará la distancia de edición mínima para transformar \(X\) en \(Y\).\\

Durante la ejecución del algoritmo, se irían calculando los valores de las celdas de manera iterativa, empezando desde los prefijos más cortos (es decir, las celdas en la esquina superior izquierda de la tabla) hasta los prefijos más largos (es decir, las celdas en la esquina inferior derecha de la tabla).\\

\subsection*{\textit{\textbf{Inciso C}}}

Si tenemos \(T[i][j]\) para todos los pares \((i, j)\) donde \(i \leq n\) y \(j \leq m\), podemos construir \(T[n][m]\) utilizando la siguiente observación:

\begin{itemize}
    \item Si el último carácter de \(A[i]\) es igual al último carácter de \(B[j]\), entonces no necesitamos hacer nada (ninguna operación de transformación) por lo que el costo (\textit{minimo edit distance}) sería igual a \(T[i-1][j-1]\).
    \item Al contrario, si el último carácter de \(A[i]\) es distinto al último carácter de \(B[j]\), podemos realizar una de las operaciones para transformar la secuencia. Entonces aquí podríamos calcular el costo de cada operación y elegir la operación con el costo mínimo (de forma recurrente). Después de realizar la operación, consideramos el costo mínimo para los prefijos restantes.
\end{itemize}

Debemos considerar el caso base, que sería cuando no se \textit{'necesiten'} funciones de transformación. Osea cuando alguna de las dos cadenas tiene una longitud \(0\), lo que significaría que como existe una cadena vacía solo debemos hacer un \textit{insert} de cada elemento o \textit{kill}.\\

Dado que en la definición del problema se nos indicaron los incrementos sobre \(i\) y \(j\) entonces, podemos utilizarlos de forma inversa para la recurrencia sobre la tabla \(T\).\\

Por lo tanto, la ecuación de recurrencia estaría dada por:

\[
T[i][j] = 
\begin{cases}
max(i,j), & \text{si } min(i,j) = 0 \\
T[i-1][j-1], & \text{si } X[i-1] = Y[j-1]\\
min\begin{cases}
costo(copy) + T[i-1][j-1]\\
costo(replace) + T[i-1][i-1]\\
costo(delete) + T[i-1][j]\\
costo(insert) + T[i][j-i]\\
costo(twiddle) + T[i-2][j-2], & \text{si i>1 y j>1} 
\end{cases}& \text{si } X[i-1] != Y[j-1]\\
\end{cases}
\]


\subsection*{Algoritmo}

\begin{minted}{python}
Algoritmo Minimum Edit Distance(x, y)
  n <- longitud(x)
  m <- longitud(y)
  Crear una matriz T de tamaño (n+1) x (m+1) inicializada con ceros
  
  Para i desde 0 hasta n inclusive hacer
    Para j desde 0 hasta , inclusive hacer
      Si min(i, j) = 0 entonces
        T[i][j] <- max(i, j)
      Si no, si x[i-1] = y[j-1] entonces
        T[i][j] <- T[i-1][j-1]
      Si no
        T[i][j] <- min( costo(copy) + T[i-1][j-1],
                         costo(replace) + T[i-1][j-1],
                         costo(delete) + T[i-1][j],
                         costo(insert) + T[i][j-1],
                         Si i>1 y j>1 entonces costo(twiddle) + T[i-2][j-2] sino infinito )
    Fin Para
  Fin Para
  Devolver T[m][n]
Fin Algoritmo
\end{minted}


La Dist