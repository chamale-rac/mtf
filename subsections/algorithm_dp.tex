\subsection{\textit{\textbf{Algoritmo de DP}}}

Al utilizar el enfoque \textit{bottom-up} en la resolución de problemas con programación dinámica, es necesario resolver subproblemas más pequeños antes de abordar los problemas más grandes. Este enfoque se basa en la idea de que la solución óptima para un problema se puede construir a partir de las soluciones óptimas de sus subproblemas más pequeños.\\

El primer paso para resolver un problema utilizando este enfoque consiste en identificar una subestructura óptima. Esto implica encontrar las decisiones necesarias para producir subproblemas. En el caso del problema \textit{Edit Distance}, es necesario definir los índices \(i\) y \(j\) sobre \(X\) y \(Y\)  para formar subcadenas y abordar los subproblemas.\\

Consideremos una secuencia de operaciones \((o_{1},\dots ,o_{k})\) que se considera óptima. Después de aplicar una de estas operaciones, podemos afirmar que se debe haber aplicado una secuencia de operaciones óptima para transformar las subcadenas de \(X\) y \(Y\).\\

Si la granularidad mínima son los caracteres individuales, el término \textit{'formulación de subcadenas'} puede resultar ambiguo. Específicamente, para generar los subproblemas, la estrategia debe ser sólida y podríamos considerar como buen acercamiento comenzar evaluando los prefijos o sufijos más cortos.\\

Durante la ejecución del algoritmo, dado que es necesario calcular los costos de las operaciones de los subproblemas, se puede comenzar de forma arbitraria desde los prefijos más cortos hasta los prefijos más largos.\\

El siguiente paso en la resolución de un problema mediante programación dinámica es encontrar el caso base, en nuestro problema ocurre cuando no se necesitan funciones de transformación. En otras palabras, esto sucede cuando una de las dos cadenas tiene una longitud de 0. Dado que una de las cadenas está vacía, simplemente debemos insertar todos los elementos de una cadena en la otra o eliminar todos los elementos de la otra cadena.\\

Para abordar el problema de manera dinámica, podemos utilizar una matriz \(T\) para almacenar los resultados de los subproblemas. Las dimensiones de la matriz \(T\) están determinadas por \(n\) y \(m\), donde \(n\) representa la longitud de la cadena \(X\) y \(m\) representa la longitud de la cadena \(Y\). \\

De esta forma cada celda \(T[i][j]\) representaría la secuencia de operaciones óptima en termino de costo para transformar el prefijo de \(X[i]\) en el prefijo \(Y[j]\).\\ 

\begin{center}
\begin{tabular}{ c |c |c |c |c |c |c }
     & Y[0] & Y[1] & Y[2] & \(\dots\) & Y[n-1] & Y[n]\\ 
     \hline
    X[0] & & & & & & \\ 
    \hline
    X[1] & & & & & & \\ 
    \hline
    X[2] & & & & & & \\ 
    \hline
    \(\dots\) & & & & & & \\ 
    \hline
    X[m-1] & & & & & & \\ 
    \hline
    X[m] & & & & & & \\ 
\end{tabular}
\end{center}

\begin{center}
\small\textcolor{FSBlue}{Representación de la matriz \(T\) que almacena los resultados de los subproblemas durante la ejecución del algoritmo. \textit{bottom-up}.}
\end{center}

Recordemos que durante la ejecución del algoritmo, se irían calculando los valores de las celdas de manera iterativa, empezando desde los prefijos más cortos (es decir, las celdas en la esquina superior izquierda de la tabla) hasta los prefijos más largos (es decir, las celdas en la esquina inferior derecha de la tabla).\\

Una vez que todos los valores de las celdas se hayan sido calculados, el valor de la celda \(T[m][n]\) representará la distancia de edición mínima para transformar \(X\) en \(Y\).\\

De forma programática, si tenemos \(T[i][j]\) para todos los pares \((i, j)\) donde \(i \leq m\) y \(j \leq n\), podemos construir \(T[m][n]\) utilizando la siguiente observación:

\begin{itemize}
    \item Si el último carácter de \(A[i]\) es igual al último carácter de \(B[j]\), entonces no necesitamos hacer nada (ninguna operación de transformación) por lo que el costo (\textit{minimo edit distance}) sería igual a \(T[i-1][j-1]\).
    \item Al contrario, si el último carácter de \(A[i]\) es distinto al último carácter de \(B[j]\), podemos realizar una de las operaciones para transformar la secuencia. Entonces aquí podríamos calcular el costo de cada operación y elegir la operación con el costo mínimo (de forma recurrente). Después de realizar la operación, consideramos el costo mínimo para los prefijos restantes.
\end{itemize}

Por lo tanto, la ecuación de recurrencia estaría dada por:\\

\[
T[i][j] = 
\begin{cases}
max(i,j), & \text{si } min(i,j) = 0 \\
T[i-1][j-1], & \text{si } X[i-1] = Y[j-1]\\
min\begin{cases}
cost(replace) + T[i-1][i-1]\\
cost(delete) + T[i-1][j]\\
cost(insert) + T[i][j-i] 
\end{cases}& \text{si } X[i-1] != Y[j-1]\\
\end{cases}
\]\\

Consiguientemente el algoritmo ser definido como:\\

\begin{minted}{python}
Edit Distance Dynamic Programming(x, y)
  m <- longitud(x)
  n <- longitud(y)
  Crear una matriz T de tamaño (m+1) x (n+1) inicializada con ceros
  
  Para i desde 0 hasta m inclusive hacer
    Para j desde 0 hasta n, inclusive hacer
      Si min(i, j) = 0 entonces
        T[i][j] <- max(i, j)
      Si no, si x[i-1] = y[j-1] entonces
        T[i][j] <- T[i-1][j-1]
      Si no
        T[i][j] <- min( costo(replace) + T[i-1][j-1],
                        costo(delete) + T[i-1][j],
                        costo(insert) + T[i][j-1] )
    Fin Para
  Fin Para
  Devolver T[m][n]
Fin Algoritmo
\end{minted}